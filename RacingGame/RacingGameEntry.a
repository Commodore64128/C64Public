!to "RacingGame.prg", cbm
!sal
!sl "RacingGame.map"
!svl "RacingGame.lbl"
!pdb "RacingGame.pdb"
!cpu 6510
!ct pet
!initmem %10101010

!source "../stdlib/stdlib.a"


Scroller_IRQVectorLo			= IRQServiceRoutineLo
Scroller_IRQVectorHi			= IRQServiceRoutineHi

Scroller_NMIVectorLo			= NMIServiceRoutineLo
Scroller_NMIVectorHi			= NMIServiceRoutineHi

; Define what the multiplexor can use
Multiplex_VarBase	= $02
Multiplex_spritepointer	= $c000+SPRITEFRAMESCROFF
Multiplex_IRQServiceRoutineLo = IRQServiceRoutineLo
Multiplex_IRQServiceRoutineHi = IRQServiceRoutineHi
Multiplex_IRQExitDefined = 1
!macro Multiplex_IRQExit {
	jmp MinimalIRQServiceRoutine
}

Multiplex_items	= 32
Multiplex_DiscardSpritesYPos=scorePanelPos1 - 1
scorePanelPos1 = VIC2SpriteYBorderTop + (20*8)

!source "..\SpriteMultiplexor\SpriteMultiplexorVars.a"

!source "asm\TrackDraw_EdgeCommon.a"

Multiplex_EnableEarlyOut = 1
Multiplex_BunchingCheck = 1

;DebugMainlineBorder = 1
;Multiplexor_DebugBorder = 1

;Debug_ForceTrackStateRender=$c7		; *Hill crest and valley
;Debug_ForceTrackStateRender=$2c		; Straight road
;Debug_ForceTrackStateRender=$4a		; *Right corner
;Debug_ForceTrackStateRender=$ca		; Hill crest and valley again
;Debug_ForceTrackStateRender=$ec		; Hill

; Zero page variables
TrackDraw_ZP_TrackLoHi		= Multiplex_endVars+$00
TrackDraw_ZP_ScreenLoHi		= Multiplex_endVars+$02

RoadObject_Max = 128


*=$400
GameStart
	lda #ProcessorPortKERNALWithIO
	jsr InitialiseMachine
	jsr UnpauseAndSetVolume

	lda #Multiplex_items
	sta Multiplex_MaxSpr
	jsr Multiplex_InitSort

	lda #0
	sta CIA2PortASerialBusVICBank
	lda #%00000010
	sta VIC2MemorySetup
	lda #VIC2ScreenControlHDefault | %10000
	sta VIC2ScreenControlH
	lda #%00011011
	sta VIC2ScreenControlV

	jsr init

!ifdef Debug_ForceTrackStateRender {
	lda #0		; Right steer (road to the left)
	lda #100	; Left steer (road to the right)
	lda #90
	lda #50		; Middle
	sta skd

	lda #Debug_ForceTrackStateRender
	sta trckoft2

!if 0 {
	lda #$1
	ldx #34
.ts1
	lda #$13
	sta objhorizl,x
	sta objhorizr,x
	dex
	lda #$1
	sta objhorizl,x
	sta objhorizr,x
	dex
	bne .ts1
}

.dl1

	lda #0
	sta VIC2BorderColour
	inc VIC2BorderColour
	lda #1
	sta topScreenBank
	jsr TrackDraw_offscreen
	inc VIC2BorderColour
	jsr TrackDraw_setup
	inc VIC2BorderColour
	jsr TrackDraw_chars
	inc VIC2BorderColour
	jsr TrackDraw_SmoothEdgeFixup
	inc VIC2BorderColour
	jsr TrackDraw_SmoothEdgeLeft
	inc VIC2BorderColour
	jsr TrackDraw_SmoothEdgeRight
	inc VIC2BorderColour
	lda #0
	sta topScreenBank
	jsr TrackDraw_colours
	jmp .dl1
}

	jsr Multiplex_StartTopInterrupt

	jsr SetupIRQs

	cli

	jmp .l1

; If this is already at 0 then don't count down and don't exit.
; If this is > 0 then count down and if the count reaches zero then exit the mainline loop.
ScrollerExitMainLineCounter !by 0
MainlineIsPaused !by 0

.pauseKeyPressed !by 0
.quitKeyPressed !by 0
.scannedKeys !by 0
.rsReleasetoggle !by 0

.l1

	; Pause and quit key check
	; MPi: TODO: Consider tidying this into a couple of functions
.lk1
	lda #0
	sta .pauseKeyPressed
	sta .quitKeyPressed
	sta CIA1KeyboardColumnJoystickA
	lda CIA1KeyboardRowsJoystickB
	cmp #$ff
	beq .noKey

	; Prime what part of the keyboard to read
	lda #%01111111
	sta CIA1KeyboardColumnJoystickA
.again
	lda CIA1KeyboardRowsJoystickB
	cmp CIA1KeyboardRowsJoystickB
	bne .again
	cmp #$ff
	beq .noKey
	sta .scannedKeys
	lda #%10000000
	bit .scannedKeys
	bne .notRunStop
	lda #1
	sta .pauseKeyPressed
.notRunStop
	lda #%01000000
	bit .scannedKeys
	bne .noKey
	lda #1
	sta .quitKeyPressed
.noKey

	; Reset the port read
	lda #%01111111
	sta CIA1KeyboardColumnJoystickA

	; Check for the fire buttons unpausing
	lda MainlineIsPaused
	beq .overFire
	lda #JoystickBits_Fire
	bit CIA1KeyboardColumnJoystickA
	beq .fireUnpause
	bit CIA1KeyboardRowsJoystickB
	beq .fireUnpause
	jmp .overFire
.fireUnpause
	jsr UnpauseAndSetVolume
.overFire

	; Check for an errant NMI being generated (like the restore key) and quit if needed.
	lda NMINotTimerGenerated
	bne .retFromGame

	; Now process the key toggle pressing
	lda .pauseKeyPressed
	beq .notPressedRS
	lda .rsReleasetoggle
	bne .overRSTest
	lda #1
	sta .rsReleasetoggle
	eor MainlineIsPaused
	sta MainlineIsPaused
	bne .overRSTest
.fireUnpause2
	jsr UnpauseAndSetVolume
	jmp .overRSTest
.notPressedRS
	lda #0
	sta .rsReleasetoggle
.overRSTest

	; Now check the pause status
	lda MainlineIsPaused
	beq .notPaused
	lda .quitKeyPressed
	beq .notPressedQ
	; Quit, yes this is really it
.retFromGame
	; TODO
	jmp GameStart
	rts
.notPressedQ
	lda #0
	sta SIDVolumeFilter
	jmp .l1
.notPaused




!ifdef DebugMainlineBorder {
	lda #VIC2Colour_Red
	sta VIC2BorderColour
}
	jsr TrackDraw_offscreen
	jsr TrackDraw_setup

!ifdef DebugMainlineBorder {
	lda #VIC2Colour_Yellow
	sta VIC2BorderColour
}
	jsr HorizonDraw

!ifdef DebugMainlineBorder {
	lda #VIC2Colour_Cyan
	sta VIC2BorderColour
}
	jsr TrackDraw_chars

!ifdef DebugMainlineBorder {
	lda #VIC2Colour_Purple
	sta VIC2BorderColour
}

	jsr TrackDraw_SmoothEdgeFixup

!ifdef DebugMainlineBorder {
	lda #VIC2Colour_Blue
	sta VIC2BorderColour
}

	jsr TrackDraw_SmoothEdgeLeft
!ifdef DebugMainlineBorder {
	lda #VIC2Colour_Green
	sta VIC2BorderColour
}
	jsr TrackDraw_SmoothEdgeRight

!ifdef DebugMainlineBorder {
	lda #VIC2Colour_Black
	sta VIC2BorderColour
}

	lda #scorePanelPos1+10
.wl1
	cmp VIC2Raster
	bne .wl1

	; Update the timed raster position from the off screen draw
	lda rast
	sta NMIRaster

	; Update the bank
	lda topScreenBank
	eor #1
	sta topScreenBank
	tax
	lda BankToAddrDisplay,x
	ora #3
	jsr Multiplex_SetSpritePointer

!ifdef DebugMainlineBorder {
	lda #VIC2Colour_White
	sta VIC2BorderColour
}
	jsr TrackDraw_colours


!ifdef DebugMainlineBorder {
	lda #VIC2Colour_Black
	sta VIC2BorderColour
}
	jmp .l1

UnpauseAndSetVolume
	lda #15
	sta SIDVolumeFilter
	lda #0
	sta MainlineIsPaused
	rts

!source "FingerPrint.a"

BankToAddrDisplay		!by $c0 , $c4
BankToAddrOffscreen		!by $c4 , $c0

!macro MSetSprite .sprite , .xpos , .ypos , .col {
	lda #(.xpos & 0xff)
	sta Multiplex_XPosLo + .sprite
	!if .xpos >= 256 {
		sty Multiplex_XPosHi + .sprite
	} else {
		stx Multiplex_XPosHi + .sprite
	}
	lda #.ypos
	sta Multiplex_YPos + .sprite
	lda #.col
	sta Multiplex_Colour + .sprite
}


; Create a 3x2 sprite block at an index, xpos, ypos and colour
!macro MSetCharacter .idx , .x , .y , .col {
	+MSetSprite .idx	, .x , .y	, .col
	+MSetSprite .idx+1  , .x+24 , .y	, .col
	+MSetSprite .idx+2  , .x , .y+21	, .col
	+MSetSprite .idx+3  , .x+24 , .y+21	, .col
	+MSetSprite .idx+4  , .x , .y+42	, .col
	+MSetSprite .idx+5  , .x+24 , .y+42	, .col
}

!zn {
init
	ldy #Multiplex_items-1
.l1
	lda #255
	sta Multiplex_YPos,y
	lda #VIC2Colour_White
	sta Multiplex_Colour,y
	dey
	bpl .l1

	ldx #0
	ldy #1
;	+MSetCharacter 0	, 100	, 50	, VIC2Colour_White
;	+MSetCharacter 6	, 50	, 60	, VIC2Colour_Green
;	+MSetCharacter 12	, 150	, 90	, VIC2Colour_Brown
;	+MSetCharacter 18	, 200	, 140	, VIC2Colour_Yellow
;	+MSetCharacter 24	, 100	, 170	, VIC2Colour_Blue
;	+MSetCharacter 30	, 230	, 190	, VIC2Colour_Red

	; Draw a car
	lda #VIC2SpriteYBorderTop + (16*8) + 4
	sta Multiplex_YPos
	sta Multiplex_YPos+1
	sta Multiplex_YPos+2
	lda #VIC2Colour_Red
	sta Multiplex_Colour
	sta Multiplex_Colour+1
	sta Multiplex_Colour+2
	lda #VIC2SpriteXBorderLeft + (15*8) + 4
	sta Multiplex_XPosLo
	clc
	adc #24
	sta Multiplex_XPosLo+1
	adc #24
	sta Multiplex_XPosLo+2
	lda #0
	sta Multiplex_XPosHi
	sta Multiplex_XPosHi+1
	sta Multiplex_XPosHi+2
	ldx #$46
	stx Multiplex_SpriteFrame
	inx
	stx Multiplex_SpriteFrame+1
	inx
	stx Multiplex_SpriteFrame+2


	lda GameScreenBGCol0
	sta VIC2ScreenColour
	lda GameScreenBGCol1
	sta VIC2ExtraBackgroundColour1
	lda GameScreenBGCol2
	sta VIC2ExtraBackgroundColour2

	jsr Multiplex_Sort

	lda #$ff
	sta VIC2SpriteMulticolour

	lda #VIC2Colour_White
	sta VIC2ExtraSpriteColour1

	lda #VIC2Colour_Black
	sta VIC2ExtraSpriteColour2

	rts
}


!source "../stdlib/Initialise.a"
!source "asm\TrackDraw.a"
!source "asm\SetupIRQs.a"
!source "asm\HorizonDraw.a"

!source "..\SpriteMultiplexor\SpriteMultiplexor.a"

GameScreenBGCol0
!bin "Graphics/Level1.ctm" , 1 , 4
GameScreenBGCol1
!bin "Graphics/Level1.ctm" , 1 , 5
GameScreenBGCol2
!bin "Graphics/Level1.ctm" , 1 , 6



*=$4000
Data_trackconfig2 = *
!source "Data/RoadYPosByRows.a"

*=$4800
!source "Data/RoadWidthByRows.a"

*=$5000
Data_trackoft = *
!bin "Original/trackoft.d.prg" ,,  2
*=$5800
Data_cornoft = *
!bin "Original/cornoft.d.prg" ,,  2
*=$7800
Data_trckcornpos = *
!bin "Original/trckcornpos.d.prg" ,,  2
*=$7900
Data_trckypos = *
!bin "Original/trckypos.d.prg" ,,  2
*=$7a00
Data_sideobjtab2 = *
!bin "Original/sideobjtab2.d.prg" ,,  2
*=$7c00
Data_blocktable = *
!source "asm/RoadObject_Macro.a"
!source "Data/Level1RoadObjects.a"


*=$8000
RoadsideObjectColourLookup
!bin "Graphics/Level1.ctm" , $100 , $814

*=$c800
!bin "Graphics/Level1.ctm" , $800 , $14

*=$d000
!bin "Graphics/Car.spd" , 15*64 , $9
