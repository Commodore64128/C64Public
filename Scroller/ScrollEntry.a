; Demonstrates 8-way scrolling with 4x4 blocks, static score panel and sprite multiplexing
; Also demonstrates SEUCK data file compatibility.
!to "Scroller.prg", cbm
!sal
!sl "Scroller.map"
!svl "Scroller.lbl"
!pdb "Scroller.pdb"
!cpu 6510
!ct pet

!source "../stdlib/stdlib.a"
!source "ScrollerVars.a"
; Define what the multiplexor can use
Multiplex_VarBase	= scrollerDemo_endVars
Multiplex_spritepointer	= $cbf8
Multiplex_IRQServiceRoutineLo = KERNALIRQServiceRoutineLo;
Multiplex_IRQServiceRoutineHi = KERNALIRQServiceRoutineHi;
Multiplex_DiscardSpritesYPos=scorePanelPos1-1
Multiplex_items	= 32
; Enable this to maintain sprite priority ordering based on Y position.
;Multiplex_MaintainPriority	= 1
; Enable this to reverse sprite ordering
;Multiplex_ReverseOrder = 1

!source "../SpriteMultiplexor/SpriteMultiplexorVars.a"
; Allows the mainline to start updating sprites earlier after the last multiplexor IRQ.
Multiplex_EnableEarlyOut = 1
; We have a lower raster for the screen split so we want to enable this functionality to give our
; IRQ time to get displayed.
Multiplex_OverflowRasterCheck1 = 1
Multiplex_OverflowRasterCheck2 = 1
; We have situations where sprites get bunched so this will allow the multiplexor to discard
; bunches of sprites and display more sprites in areas of heavy use.
Multiplex_BunchingCheck = 1

; Debug colour changes for the border
; Turning this on can cause some extra sprite flicker in tight formations because the colour
; changes take up extra time
;Multiplexor_DebugBorder = 1
; IRQs generated by this application and not those generated by the multiplexor.
;Scroller_DebugIRQBorder = 1
; NMIs generated by this application
;Scroller_DebugNMIBorder = 1
; Non-interrupt timings
;Scroller_DebugMainlineBorder = 1
;Scroller_DebugColourScrollTimings = 1
;Scroller_DebugScreenScrollTimings = 1

; Define this to demonstrate a multi-directional scroller.
; Undefine this to enable SEUCK data file compatibility.
;Scroller_MultiDirection = 1
!ifdef Scroller_MultiDirection { } else {

; Pixel accurate collision enable
; Disabling this will disable all SEUCK collisions.
Multiplex_LogCollisions = 1
Multiplexor_UpdateCollisionDetailsSoftEnable = 1

; Stop the multiplexor allocating static memory and use reserved memory instead
Multiplex_LeanAndMean = 1

; Define this to use horizontal scrolling SEUCK instead
;Scroller_IsHorizontal = 1

; Define this to cause the extended code for Legion of the Damned to be used
;Scroller_LOTD = 1

; Undefine this to only play music instead of sound effects during the game
Scroller_PlaySoundEffectsDuringGame = 1

; Define this to cause animating sprites to be displayed on the title screen instead of raster bar text
;TitleScreen_AnimatingSprites = 1

; Define this separately to Scroller_LOTD if you just want the linked enemy test enabled
; MPi: TODO: Double check with GAME1__I.P00 that the linked enemy test work only by the killable
; parts of the enemy causing the explosion. The linked first boss "wings" shouldn't be causing a kill.
Scroller_LinkedEnemyTest = 1

; Define this to link player 1 and 2 sprites together so that one joystick can control both players.
; The code will permanently offset the "player 2" sprite using Scroller_LinkedPlayersOffsetX and Scroller_LinkedPlayersOffsetY
; When one player animation explodes dies the other player animation explodes at the same time.
;Scroller_LinkedPlayers = 1
Scroller_LinkedPlayersOffsetX = 24
Scroller_LinkedPlayersOffsetY = 0

!ifdef Scroller_LinkedPlayers {
Scroller_SingleScoreLives = 1	; This must be always enabled if Scroller_LinkedPlayers is enabled
}

; Define this to enable both players but they are controlled by one stick.
; Both players have independent collision.
; Consider enabling Scroller_SingleScoreLives at the same time. It isn't mandatory though. :)
;Scroller_TwinMode = 1

; Define this so there is one score and lives displayed even if two players are active.
; In other words the life count and score is shared. When both players have died then the game ends.
; Most often used with Scroller_LinkedPlayers or Scroller_TwinMode.
;Scroller_SingleScoreLives = 1

!ifdef Scroller_TwinMode {
!ifdef Scroller_LinkedPlayers {
!error Cannot enable Scroller_TwinMode and Scroller_LinkedPlayers at the same time
}
}

; Turns on the linked enemy test in LoTD if it isn't already enabled
; If Scroller_LOTD is enabled then turn on the linked enemy and horizontal flag by default
!ifdef Scroller_LOTD {
!ifdef Scroller_LinkedEnemyTest { } else {
Scroller_LinkedEnemyTest = 1
}
!ifdef Scroller_IsHorizontal {} else {
Scroller_IsHorizontal = 1
}
}

; Define this to completely disable any music being included
;Scroller_NoMusic = 1


; MPi: TODO: Double check the sprite X and Y placement in normal SEUCK and horizontal SEUCK.
; Check final placement of enemies with scrolling levels that scroll to static screens and also
; just the static screens. Check push scroll as well.
; In the horizontal SEUCK games there is a chance the sprites are appearing one pixel offset from
; where they should be.
; I have a theory the problem is with the original SEUCK code where the sprites can lag one frame
; position behind a scroll. This does mean that there is no easy fix since while scrolling people
; might have placed their sprites to compensate for this one frame lag. In this case just make
; sure the sprite position is correct when the screen is static or stops scrolling (like that 
; scroll after a push scroll).
!ifdef Scroller_IsHorizontal {
; Horizontal SEUCK: Define this to not use the sprite Y adjustment code.
Scroller_NoSpriteYAdjust = 1
; Define this to enable the sprite X coord adjustment code.
Scroller_SpriteXAdjust = 1
}


}
;Enable full screen or use the lower screen split
Scroller_FullScreen = 1
; Enable the following line to allow the bottom and top borders to be opened and have sprites.
; This is only used when Scroller_FullScreen is enabled
!ifdef Scroller_FullScreen {
IRQOpenBorders = 1
}

;Enable this to allow the enemy AI test code to be enabled with background collision.
; This will replace the all enemy object type 24 with an enemy that will run around. (.doRunningMan in AnimationEngine.a)
; Enable the ENEMYTST.P00 in ScrollerData.a to include a suitable game file.
; This example file contains a first screen (for 60 seconds) with a "box" shape where three AI units will try to escape.
; They will be constrained by this box until it is removed by the next screen.
;EnemyAITest = 1

;Enable this to allow enable one enemy that will use directional fire instead of random fire.
; This will replace the all enemy object type 23 with an enemy that will shoot at the player. (.doAimedFire in AnimationEngine.a)
; Enable the NMYFRTST.P00 in ScrollerData.a to include a suitable game file.
; This example file is a first screen (for 60 seconds) with an enemy that circles the player.
; The enemy will shoot in the general direction of the player even though it is set to random in SEUCK.
;EnemyAimTest = 1

;Enable this to use the last directional input when the animation ends.
; Original SEUCK actually defaults to direction 0 which makes enemies fire upwards.
; Enabling this will override the default SEUCK behaviour
;OverrideDefaultAnimationDirection = 1


; This code is post-build linked with a decompression stage so we don't use any BASIC sys start code here.
; Instead the start for the code is $400 which is quickly overwritten by other data once the
; real game code starts.
*=$400
	; Setup a nice stable blank screen and known machine state
	lda #ProcessorPortAllRAMWithIO
	jsr InitialiseMachine
	; Setup NMI because the initialise points to code that gets overwritten
	lda #<ScrollerNMI1
	sta KERNALNMIServiceRoutineLo
	lda #>ScrollerNMI1
	sta KERNALNMIServiceRoutineHi
	lda #0
	sta VIC2SpriteDoubleWidth
	sta VIC2SpriteDoubleHeight
	sta VIC2SpritePriority
	sta VIC2SpriteMulticolour
	; One time initialisation like moving memory around to the correct places and pre-calculation.
	jsr ScrollerDemoInitOneTimeData
	jmp ScrollEntry
	; This initialise code is here because we only use it once. Later the code is written
	; by the title screen display code.
!source "../stdlib/Initialise.a"
!source "OneTime.a"
	; The start of the real code. Memory from $400 to $fff is written by the title screen display code
*=$1000
!zn
ScrollEntry
	; The following can be called more than once if needed for a proper game type cycle
.l1
!ifdef Scroller_MultiDirection { } else {
	jsr DisplayTitleScreen
}
	jsr InitialiseGame
	jsr SetupIRQs
	jsr ScrollerDemoWaitTopIRQWithReSync
	jsr ScrollerDemoMainline
	jmp .l1

!source "SetupIRQs.a"
!source "ScrollMain.a"
; The multiplexor uses the MultiplexExt_LastIRQ label defined in "SetupIRQs.a"
!source "../SpriteMultiplexor/SpriteMultiplexor.a"

!source "ScrollerData.a"
