; Demonstrates 8-way scrolling with 4x4 blocks, static score panel and sprite multiplexing
; Also demonstrates SEUCK data file compatibility.
!to "Scroller.prg", cbm
!sal
!sl "Scroller.map"
!svl "Scroller.lbl"
!pdb "Scroller.pdb"
!cpu 6510
!ct pet

!source "../stdlib/stdlib.a"
!source "ScrollerVars.a"
; Define what the multiplexor can use
Multiplex_VarBase	= scrollerDemo_endVars
Multiplex_spritepointer	= $cbf8
Multiplex_IRQServiceRoutineLo = KERNALIRQServiceRoutineLo;
Multiplex_IRQServiceRoutineHi = KERNALIRQServiceRoutineHi;
Multiplex_DiscardSpritesYPos=scorePanelPos1-1
Multiplex_items	= 32
; Enable this to maintain sprite priority ordering based on Y position.
;Multiplex_MaintainPriority	= 1
; Enable this to reverse sprite ordering
;Multiplex_ReverseOrder = 1

!source "../SpriteMultiplexor/SpriteMultiplexorVars.a"
; Allows the mainline to start updating sprites earlier after the last multiplexor IRQ.
Multiplex_EnableEarlyOut = 1
; We have a lower raster for the screen split so we want to enable this functionality to give our
; IRQ time to get displayed.
Multiplex_OverflowRasterCheck1 = 1
Multiplex_OverflowRasterCheck2 = 1
; We have situations where sprites get bunched so this will allow the multiplexor to discard
; bunches of sprites and display more sprites in areas of heavy use.
Multiplex_BunchingCheck = 1

; Debug colour changes for the border
; Turning this on can cause some extra sprite flicker in tight formations because the colour
; changes take up extra time
;Multiplexor_DebugBorder = 1
; IRQs generated by this application and not those generated by the multiplexor.
;Scroller_DebugIRQBorder = 1
; NMIs generated by this application
;Scroller_DebugNMIBorder = 1
; Non-interrupt timings
;Scroller_DebugMainlineBorder = 1
;Scroller_DebugColourScrollTimings = 1
;Scroller_DebugScreenScrollTimings = 1
;Scroller_DebugParalaxScrollTimings = 1

; Define this to demonstrate a multi-directional scroller.
; Undefine this to enable SEUCK data file compatibility.
;Scroller_MultiDirection = 1
!ifdef Scroller_MultiDirection { } else {

; Pixel accurate collision enable
; Disabling this will disable all SEUCK collisions.
Multiplex_LogCollisions = 1
Multiplexor_UpdateCollisionDetailsSoftEnable = 1

; Stop the multiplexor allocating static memory and use reserved memory instead
Multiplex_LeanAndMean = 1

; Define this to use horizontal scrolling SEUCK instead
;Scroller_IsHorizontal = 1

; Define this to cause the extended code for Legion of the Damned to be used.
; Press 'S' female wind spell effect
; Press 'K' male fire spell effect
;Scroller_LOTD = 1

; Undefine this to only play music instead of sound effects during the game
Scroller_PlaySoundEffectsDuringGame = 1

; Define this to cause animating sprites to be displayed on the title screen instead of raster bar text
;TitleScreen_AnimatingSprites = 1

; Define this separately to Scroller_LOTD if you just want the linked enemy test enabled
Scroller_LinkedEnemyTest = 1

; Define this to link player 1 and 2 sprites together so that one joystick can control both players.
; The code will permanently offset the "player 2" sprite using Scroller_LinkedPlayersOffsetX and Scroller_LinkedPlayersOffsetY
; When one player animation explodes dies the other player animation explodes at the same time.
;Scroller_LinkedPlayers = 1
Scroller_LinkedPlayersOffsetX = 24
Scroller_LinkedPlayersOffsetY = 0

!ifdef Scroller_LinkedPlayers {
Scroller_SingleScoreLives = 1	; This must be always enabled if Scroller_LinkedPlayers is enabled
}

; Define this to enable both players but they are controlled by one stick.
; Both players have independent collision.
; Consider enabling Scroller_SingleScoreLives at the same time. It isn't mandatory though. :)
;Scroller_TwinMode = 1

; Define this so there is one score and lives displayed even if two players are active.
; In other words the life count and score is shared. When both players have died then the game ends.
; Most often used with Scroller_LinkedPlayers or Scroller_TwinMode.
;Scroller_SingleScoreLives = 1

!ifdef Scroller_TwinMode {
!ifdef Scroller_LinkedPlayers {
!error Cannot enable Scroller_TwinMode and Scroller_LinkedPlayers at the same time
}
}

; Enable this to allow player collision to escape situations where it might get stuck by collision character geometry.
; This uses more slightly processor time though.
;CollisionAllowEscape = 1

; This adds the pixel offset to the collision calculation for each sprite
; To disable these set them to 0
CollisionHotSpotTweakY = 8
CollisionHotSpotTweakX = 4

; Enable this to try searching the other player's safe position if the respawn position would result in death for the player.
TryOtherPlayerSafePositionForRespawn = 1

; Turns on the linked enemy test in LoTD if it isn't already enabled
; If Scroller_LOTD is enabled then turn on the linked enemy and horizontal flag by default
!ifdef Scroller_LOTD {
!ifdef Scroller_LinkedEnemyTest { } else {
Scroller_LinkedEnemyTest = 1
}
!ifdef Scroller_IsHorizontal {} else {
Scroller_IsHorizontal = 1
}
}

; Define this to completely disable any music being included
;Scroller_NoMusic = 1


; Enable this to add paralax scrolling update code to the SEUCK Redux engine
;Paralax_Enable = 1
; Two layer paralax scrolling of up to two 5x5 character blocks with optional proper masking or logical OR combination.
; Each column of paralax chars are sequential. i.e. The blocks numbers must increment as they go down the block.
; Enable PARLXTST.P00 (saved from ParalaxTest.vsf) in the ScrollerData.a file
; PARLXTST.P00 is the main game data file.
; The Paralax_Level1CharData, Paralax_Level1CharDataMask and Paralax_Level2CharData use a separate file in the +SEUCKFileDataParalaxBlock macro.
;   This uses only the characters from the block data in PRLXBLCK.P00 saved from ParalaxTestBlocksOnly.vsf
;	This means the two level paralax char data doesn't need to be in the main SEUCK file (the rendered characters that show the paralax effect still need to be reserved of course).
;   All characters from Paralax_CharStart to Paralax_CharStart+(Paralax_Width*Paralax_Height)-1 will be used for rendering the effect. Don't try to put your characters there because they will get overwritten.
!ifdef Paralax_Enable {
; Enable this to use a proper bitwise mask when updating the two different paralax levels.
Paralax_MaskEnable = 1
; The start character in the main SEUCK file for the displayed paralax scrolling in the game
Paralax_CharStart = 0
; The paralax area in characters.
Paralax_Width = 5
Paralax_Height = 5
; The start offsets for the two paralax levels
; Foreground level
Paralax_CharLevel1 = 32
; Background level
Paralax_CharLevel2 = 64
}


; MPi: TODO: Add new map, blocks and chars to the multi-directional scrolling demo.



; MPi: TODO: Double check the sprite X and Y placement in normal SEUCK and horizontal SEUCK.
; Check final placement of enemies with scrolling levels that scroll to static screens and also
; just the static screens. Check push scroll as well.
; In the horizontal SEUCK games there is a chance the sprites are appearing one pixel offset from
; where they should be.
; I have a theory the problem is with the original SEUCK code where the sprites can lag one frame
; position behind a scroll. This does mean that there is no easy fix since while scrolling people
; might have placed their sprites to compensate for this one frame lag. In this case just make
; sure the sprite position is correct when the screen is static or stops scrolling (like that 
; scroll after a push scroll).
!ifdef Scroller_IsHorizontal {
; Horizontal SEUCK: Define this to not use the sprite Y adjustment code.
Scroller_NoSpriteYAdjust = 1
; Define this to enable the sprite X coord adjustment code.
Scroller_SpriteXAdjust = 1
}


}

; MPi: TODO: Add configuration to shift the screen split down one or two characters giving different size bottom areas.
; Things to tweak: scorePanelPos1 , (19*40) and (20*40) will need to be optionally enabled, MACROScrollerBottomAdjust , MACROScrollerDrawVStrip, MACROScrollerDrawVStripColour, ScrollerDrawStripBottomBank,
; ScrollerDrawStripBottomColour, DrawMap
;Enable full screen or use the lower screen split
Scroller_FullScreen = 1

!ifdef Scroller_FullScreen {
; Enable the following line to allow the bottom and top borders to be opened and have sprites.
; This is only used when Scroller_FullScreen is enabled
IRQOpenBorders = 1
}

;Enable this to allow the enemy AI test code to be enabled with background collision.
; This will replace the all enemy object type 24 with an enemy that will run around. (.doRunningMan in AnimationEngine.a)
; Enable the ENEMYTST.P00 in ScrollerData.a to include a suitable game file.
; This example file contains a first screen (for 60 seconds) with a "box" shape where three AI units will try to escape.
; They will be constrained by this box until it is removed by the next screen.
;EnemyAITest = 1

;Enable this to allow enable one enemy that will use directional fire instead of random fire.
; This will replace the all enemy object type 23 with an enemy that will shoot at the player. (.doAimedFire in AnimationEngine.a)
; Enable the NMYFRTST.P00 in ScrollerData.a to include a suitable game file.
; This example file is a first screen (for 60 seconds) with an enemy that circles the player.
; The enemy will shoot in the general direction of the player even though it is set to random in SEUCK.
;EnemyAimTest = 1

;Enable this to use the last directional input when the animation ends.
; Original SEUCK actually defaults to direction 0 which makes enemies fire upwards.
; Enabling this will override the default SEUCK behaviour
;OverrideDefaultAnimationDirection = 1


; Set these two values to the x position for the player's score panels
ScorePlayer1XPos = 44
ScorePlayer2XPos = 228



; This code is post-build linked with a decompression stage so we don't use any BASIC sys start code here.
; Instead the start for the code is $400 which is quickly overwritten by other data once the
; real game code starts.
*=$400
	; Setup a nice stable blank screen and known machine state
	lda #ProcessorPortAllRAMWithIO
	jsr InitialiseMachine
	; Setup NMI because the initialise points to code that gets overwritten
	lda #<ScrollerNMI1
	sta KERNALNMIServiceRoutineLo
	lda #>ScrollerNMI1
	sta KERNALNMIServiceRoutineHi
	lda #0
	sta VIC2SpriteDoubleWidth
	sta VIC2SpriteDoubleHeight
	sta VIC2SpritePriority
	sta VIC2SpriteMulticolour
	; One time initialisation like moving memory around to the correct places and pre-calculation.
	jsr ScrollerDemoInitOneTimeData
	jmp ScrollEntry
	; This initialise code is here because we only use it once. Later the code is written
	; by the title screen display code.
!source "../stdlib/Initialise.a"
!source "OneTime.a"
	; The start of the real code. Memory from $400 to $fff is written by the title screen display code
*=$1000
!zn
ScrollEntry
	; The following can be called more than once if needed for a proper game type cycle
.l1
!ifdef Scroller_MultiDirection { } else {
	jsr DisplayTitleScreen
}
	jsr InitialiseGame
	jsr SetupIRQs
	jsr ScrollerDemoWaitTopIRQWithReSync
	jsr ScrollerDemoMainline
	jmp .l1

!source "SetupIRQs.a"
!source "ScrollMain.a"
; The multiplexor uses the MultiplexExt_LastIRQ label defined in "SetupIRQs.a"
!source "../SpriteMultiplexor/SpriteMultiplexor.a"

!source "ScrollerData.a"
