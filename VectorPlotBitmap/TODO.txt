TODO

When SpanPlot_MaskEnds	= 1 is disabled the demo corrupts the screen and crashes?



* SpanCalc_expireCleared/SpanCalc_dirtyClear logic needs to take into account for segments and the number of screen banks



* Added SpanCalc_ tables and quick conversion into the current scan
	Need to efficiently scan generic polys into SpanCalc_
	* Add a polygon scan conversion into spans.
		Make it so that multiple calls add more spans into the existing buffer.
		Spans for each scanline can be maintained, they can be chopped/merged as the polygon plotter wants to insert spans
	* At the moment SpanCalc_screenSegments* are kSpanPlot_maxHeight*kSpanCalc_maxSegments in size.
	Added SpanCalc_scanPoly
		* Need to handle;
			; MPi: TODO: Going to have to make this a macro and generify it, or have optimised code for each SpanCalc_screenNumSegments
		* The generic routine can process segments repeatedly from the left. When one segment has been processed then change the input span points Poly_linesLeft/Poly_linesRight as necessary
			* Check for the same colours next to each other and adjust sizes as necessary
			* Also if there is a 0 length then remove as necessary
			* Can unroll this routine to spot length or colour optimisations and adjust SpanCalc_screenNumSegments
			* Then if there is still span data, i.e. Poly_linesRight-Poly_linesLeft > 0, then keep on processing by jumping back into .notFullWidth



* For the number of screen buffers, if the scan is changed reset a counter.
	Or increment if unchanged.
	After the number of screen buffers passes, then change it it to empty, zero segments by setting the high byte if the segment link list to 0.
	Optimisation to skip the cmp is to use the -ve to +ve switch check. Set a newly plotted scan to 127 - frames. Then when -ve skip entirely.

	* Start with zero segments, meaning don't draw that scan.

		When adding into zero then init with the clear line colour.
		This is a dirty line optimisation, like dirty rectangle.

	* After rendering the "clear screen" pass will just set any used scanlines just rendered to a full clear line colour that is then retired after the number of screen buffer passes, or further rendering passes



* Colour 0 can be a special case for the plot, the ends can effectively be clears instead
	Have an option to mask or just round the end to the nearest 4 pixels



* Add 3D calculation to create spans
	Poly_linesLeft and Poly_linesRight


* If EnableInterlace is enabled can we use half of kSpanPlot_maxHeight?
	The "; Setup the current scan from the scans table" would need to use half of x into the SpanCalc_ tables



* There is an optmisation for the cart bank packing where the code, because it's position independant, can be put anywhere.
	The MakeCart option can be optimised to use the same space packing technique as the streaming cartridge link list output, but without the link list header.
	If each raw chunk of code saved to a 00 or x00 aligned filename and MakCart also saved to _f_index.a file it would be easier to create the lookup table from the CartFile1_Bank_X and CartFile1_Start_X labels
