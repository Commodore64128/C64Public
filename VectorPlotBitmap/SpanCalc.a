!zn
SpanCalc_dirtyClear
	ldx #kSpanPlot_maxHeight
.l1
	lda SpanCalc_screenNumSegments-1,x
	beq .o1

	lda #1
	sta SpanCalc_screenNumSegments-1,x
	lda #kSpanPlot_maxLen
	sta SpanCalc_screenSegmentsLen-1,x
	lda #kSpanCalc_backgroundColour
	sta SpanCalc_screenSegmentsColour-1,x

.o1
	dex
	bne .l1
	rts

!zn
SpanCalc_expireCleared
	ldx #kSpanPlot_maxHeight
.l1
	lda SpanCalc_screenNumSegments-1,x
	cmp #1
	bne .o1

	lda SpanCalc_screenSegmentsColour-1,x
	cmp #kSpanCalc_backgroundColour
	bne .o1

	lda #0
	sta SpanCalc_screenNumSegments-1,x

.o1
	dex
	bne .l1
	rts

!zn
	; Scenario: Simple half length insertion test into empty line at middle
.notAtLeft0
	; Handle a segment not at the left hand side
	sta SpanCalc_screenSegmentsLen,x
	lda #kSpanCalc_backgroundColour
	sta SpanCalc_screenSegmentsColour,x

	lda Poly_linesRight,x
	sec
	sbc Poly_linesLeft,x
	sta SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x
	lda .smCurrentColour
	sta SpanCalc_screenSegmentsColour + kSpanPlot_maxHeight,x

	lda #2
	sta SpanCalc_screenNumSegments,x

	lda Poly_linesRight,x
	cmp #kSpanPlot_maxLen
	beq .noRightSegment0	; Scenario: Simple length insertion test into empty line at end

	; Scenario: Simple half length insertion test into empty line at middle
	lda #kSpanPlot_maxLen
	sec
	sbc Poly_linesRight,x
	sta SpanCalc_screenSegmentsLen + (2*kSpanPlot_maxHeight),x
	lda #kSpanCalc_backgroundColour
	sta SpanCalc_screenSegmentsColour + (2*kSpanPlot_maxHeight),x

	inc SpanCalc_screenNumSegments,x

.noRightSegment0
	jmp .nextLine

.emptyLineCase
	lda Poly_linesLeft,x
	bne .notAtLeft0

	lda Poly_linesRight,x
	cmp #kSpanPlot_maxLen
	beq .isWholeLine0

	; Scenario: Simple half length insertion test into empty line at start
	sta SpanCalc_screenSegmentsLen,x
.smCurrentColour = *+1
	lda #0
	sta SpanCalc_screenSegmentsColour,x

	lda #kSpanPlot_maxLen
	sec
	sbc Poly_linesRight,x
	sta SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x
	lda #kSpanCalc_backgroundColour
	sta SpanCalc_screenSegmentsColour + kSpanPlot_maxHeight,x

	lda #2
	sta SpanCalc_screenNumSegments,x

	jmp .nextLine

	; Scenario: Simple maximum length insertion test into empty line
.isWholeLine0
	sta SpanCalc_screenSegmentsLen,x

 	lda .smCurrentColour
	sta SpanCalc_screenSegmentsColour,x

	lda #1
	sta SpanCalc_screenNumSegments,x

	jmp .nextLine

.ltestNumSegments2 jmp .testNumSegments2
; Entry:
; A = colour
; X = start line index
; Y = end line index (+ 1)
SpanCalc_scanPoly
	sta .smCurrentColour
	sty .smLoopEnd
.l1

	; Check for whole line special case
	lda Poly_linesLeft,x
	bne .notFullWidth
	lda Poly_linesRight,x
	cmp #kSpanPlot_maxLen
	bne .notFullWidth

	beq .isWholeLine0

.notFullWidth
	; Update the spans
	ldy SpanCalc_screenNumSegments,x
	beq .emptyLineCase

	cpy #1
	beq .testNumSegments1

	cpy #2
	beq .ltestNumSegments2

	; MPi: TODO: Going to have to make this a macro and generify it, or have optimised code for each SpanCalc_screenNumSegments
	brk

.nextLine
	inx
.smLoopEnd = *+1
	cpx #0
	bne .l1
	
	rts

.testNumSegments1
	; For SpanCalc_screenNumSegments = 1
	; Assume the entire line is correctly set to be kSpanPlot_maxLen for this case

	; Spot the case where we don't need to do anything because the colour is the same
	; This special case can assume the whole line is the same colour so no need to do line start/end colour tests
	lda SpanCalc_screenSegmentsColour,x
	cmp .smCurrentColour
	bne .differentColour1
	jmp .nextLine	; Scenario: Simple half length insertion test into filled line, * same colour
.differentColour1

	lda Poly_linesLeft,x
	bne .notAtLeft1

	lda Poly_linesRight,x
	cmp #kSpanPlot_maxLen
	bne .needToSplit1

	; Scenario: Simple maximum length insertion test into filled line, same length different colour
	lda .smCurrentColour
	sta SpanCalc_screenSegmentsColour,x
	jmp .nextLine

.needToSplit1
	lda #kSpanPlot_maxLen
	sec
	sbc Poly_linesRight,x
	sta SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x
	lda SpanCalc_screenSegmentsColour,x
	sta SpanCalc_screenSegmentsColour + kSpanPlot_maxHeight,x

	lda Poly_linesRight,x
	sta SpanCalc_screenSegmentsLen,x
	lda .smCurrentColour
	sta SpanCalc_screenSegmentsColour,x

	inc SpanCalc_screenNumSegments,x

	jmp .nextLine

.notAtLeft1
	lda Poly_linesRight,x
	cmp #kSpanPlot_maxLen
	bne .notAtRight1

	; Scenario: Simple half length insertion test into filled line, on right different colour
	lda Poly_linesLeft,x
	sta SpanCalc_screenSegmentsLen,x

	lda #kSpanPlot_maxLen
	sec
	sbc Poly_linesLeft,x
	sta SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x
	lda .smCurrentColour
	sta SpanCalc_screenSegmentsColour + kSpanPlot_maxHeight,x

	inc SpanCalc_screenNumSegments,x

	jmp .nextLine

 
.notAtRight1
	
	; Adjust left segment
	lda Poly_linesLeft,x
	sta SpanCalc_screenSegmentsLen,x

	; Create right segment from left segment
	lda #kSpanPlot_maxLen
	sec
	sbc Poly_linesRight,x
	sta SpanCalc_screenSegmentsLen + (2*kSpanPlot_maxHeight),x
	lda SpanCalc_screenSegmentsColour,x
	sta SpanCalc_screenSegmentsColour + (2*kSpanPlot_maxHeight),x

	; Create middle segment
	lda Poly_linesRight,x
	sec
	sbc Poly_linesLeft,x
	sta SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x
	lda .smCurrentColour
	sta SpanCalc_screenSegmentsColour + kSpanPlot_maxHeight,x

	lda #3
	sta SpanCalc_screenNumSegments,x

	jmp .nextLine



.testNumSegments2
	; For SpanCalc_screenNumSegments = 2

;	lda SpanCalc_screenSegmentsColour,x
;	cmp .smCurrentColour
;	bne .differentColour2
;	jmp .nextLine	; Scenario: 
;.differentColour2

	lda Poly_linesLeft,x
	bne .notAtLeft2

	; Handle cases where the poly starts on the left
	lda Poly_linesRight,x
	cmp SpanCalc_screenSegmentsLen,x
	beq .replaceThisSegment2_0
	bcs .needToAdjust2_1

	lda SpanCalc_screenSegmentsColour,x
	cmp .smCurrentColour
	bne .differentColour2_0
	jmp .nextLine

.differentColour2_0
	; Scenario: Simple length insertion test into filled line with 2 segments, on left, shorter length different colour
	; Insert segment
	lda #3
	sta SpanCalc_screenNumSegments,x

	; Insert
	lda SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x
	sta SpanCalc_screenSegmentsLen + (2*kSpanPlot_maxHeight),x
	lda SpanCalc_screenSegmentsColour + kSpanPlot_maxHeight,x
	sta SpanCalc_screenSegmentsColour + (2*kSpanPlot_maxHeight),x

	; Split 0 trailing right
	lda SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x
	sec
	sbc Poly_linesRight,x
	sta SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x
	lda SpanCalc_screenSegmentsColour,x
	sta SpanCalc_screenSegmentsColour + kSpanPlot_maxHeight,x
	
	; Add new at 0
	lda Poly_linesRight,x
	sta SpanCalc_screenSegmentsLen,x
	lda .smCurrentColour
	sta SpanCalc_screenSegmentsColour,x

	jmp .nextLine


.replaceThisSegment2_0

	; Scenario: Simple length insertion test into filled line with 2 segments, same length different colour on left
	lda .smCurrentColour
	sta SpanCalc_screenSegmentsColour,x
	jmp .nextLine

.needToAdjust2_1
	; Scenario: Simple length insertion test into filled line with 2 segments, on left, longer length different colour
	sta SpanCalc_screenSegmentsLen,x
	lda .smCurrentColour
	cmp SpanCalc_screenSegmentsColour + kSpanPlot_maxHeight,x
	bne .differentColour2_1

	; Scenario: Simple length insertion test into filled line with 2 segments, on left, longer length same colour as 2nd
	lda #kSpanPlot_maxLen
	jmp .isWholeLine0

.differentColour2_1
	sta SpanCalc_screenSegmentsColour,x
	lda #kSpanPlot_maxLen
	sec 
	sbc Poly_linesRight,x
	sta SpanCalc_screenSegmentsLen + kSpanPlot_maxHeight,x

	jmp .nextLine

.notAtLeft2
	brk
	jmp .nextLine
